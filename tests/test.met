# classes et fonctions.
# if
# fonctions -> avec scope statique, surdefs, ...
# boucles
# 
# Proposition pour les classes: on stocke une r√©f√©rence sur le code
# -> les variables contiennent des pointeurs vers les donn√©es
# -> on retrouve les infos √  l'aide de tables de correspondance
# -> ClassInfo contient la liste de variable de types avec les param√®tres (redondant, mais permettant de manipuler les types pas d√©finis)
    
# MUST be defined first
class Class
    pass
    
class Def
    pass
    
# MUST be defined before any find_var
class Callable[ surdef_list, self_type, parm_type ]
    pass

class SurdefList
    pass
    
class Void
    def write_to_stream os
        os << "void"

class Type
    pass
    
class SI32
    ___set_base_size_and_alig 32, 32
    
    def init
    
    def init val : SI32
        ___reassign_rec val
    
    def reassign val : SI32
        ___reassign_rec val
    
class SI64
    ___set_base_size_and_alig 64, 32
    
    def init val : SI64
        ___reassign_rec val
    
    def reassign val : SI64
        ___reassign_rec val
    
class PI64
    ___set_base_size_and_alig 64, 32
    
    def init val : PI64
        ___reassign_rec val
    
    def reassign val : PI64
        ___reassign_rec val

class Bool
    ___set_base_size_and_alig 1, 1

    def init val : SI32
        ___info val
        ___reassign_rec val
    
    
void := Void()
        
# default init, that does nothing
def init self
    

class Toto
    a := 10
    def init : a( 50 ) # and b( 10 )
    

a := false # Bool( 10 )
b := Bool 35
# a.init( 23 )
# if ___rand()
    # a = 20
    
___info a

# -> faire une liste avec les surdefs...
# -> les variables pour les d√©finitions doivent appara√Ætre dans les param√®tres 
#    template, avec equal d√©fini dessus.
# -> prop 1: surdef_list est un type de taille variable, avec nb_surdefs puis les refs sur les defs
# -> REFS: on stocke 
# class Callable[ surdef_list, self_type, parm_type ]
# a := 10l
# ___syscall 60l, a
# 
# probl√®me avec f( def toto ... ) -> le code g√©n√©r√© pour la fonction f ne sera pas d√©pendant du type. Ce n'est pas forc√©ment un probl√®me si on g√®re les virtual dans Def... mais √ßa se mort la queue : il faut qd m√™me un nouveau type derri√®re
# Rq: un type se fait √  partir d'un ClassInfo, qui vient de class_type.expr()
# class_info devrait aussi √™tre un type diff√©rent, ...
# Proposition pour simplifier (ne pas se mordre la queue), class Toto et def Toto ne renvoient rien !
# inst := Toto()
# ___syscall inst.t

# if ___rand()
    # 

    
    
