# classes et fonctions.
# if
# fonctions -> avec scope statique, surdefs, ...
# boucles
# 
# Proposition pour les classes: on stocke une référence sur le code
# -> les variables contiennent des pointeurs vers les données
# -> on retrouve les infos à l'aide de tables de correspondance
# -> ClassInfo contient la liste de variable de types avec les paramètres (redondant, mais permettant de manipuler les types pas définis)
# class Callable
    # pass
    
# MUST be defined first
class Class
    pass
    
class Def
    pass
    
# MUST be defined before any find_var
class Callable[ surdef_list, self_type, parm_type ]
    pass

class SurdefList
    pass
    
class Void
    pass

class Type
    pass
    
class SI32
    ___set_base_size_and_alig 32, 32
    def reassign( val : SI32 )
        ___reassign_rec val
    
class SI64
    ___set_base_size_and_alig 64, 32
    def reassign( val : SI64 )
        ___reassign_rec val
    
class Toto
    a := 10

def toto( a )
    ___syscall a
    
# t := Toto()
# ___info t
# t.a = 17
# ___info t.a
a := 987l
a = 55l
___syscall a

# -> faire une liste avec les surdefs...
# -> les variables pour les définitions doivent apparaître dans les paramètres 
#    template, avec equal défini dessus.
# -> prop 1: surdef_list est un type de taille variable, avec nb_surdefs puis les refs sur les defs
# -> REFS: on stocke 
# class Callable[ surdef_list, self_type, parm_type ]
# a := 10l
# ___syscall 60l, a
# 
# problème avec f( def toto ... ) -> le code généré pour la fonction f ne sera pas dépendant du type. Ce n'est pas forcément un problème si on gère les virtual dans Def... mais ça se mort la queue : il faut qd même un nouveau type derrière
# Rq: un type se fait à partir d'un ClassInfo, qui vient de class_type.expr()
# class_info devrait aussi être un type différent, ...
# Proposition pour simplifier (ne pas se mordre la queue), class Toto et def Toto ne renvoient rien !
# inst := Toto()
# ___syscall inst.t

# if ___rand()
    # 

    
    
