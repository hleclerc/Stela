// Generated by CoffeeScript 1.4.0
var AsmMod, asm_mod;

AsmMod = (function() {

  AsmMod.page_size = 8192;

  AsmMod.global = typeof window !== "undefined" && window !== null ? window : global;

  function AsmMod() {
    var e, i, s, _i;
    this.modules = [];
    this.heap = new ArrayBuffer(0x10000);
    this.busy_pages = new Map;
    for (e = _i = 2; _i <= 12; e = ++_i) {
      s = 1 << e;
      this.busy_pages.set(s, {
        free: [],
        full: []
      });
    }
    this.free_pages = (function() {
      var _j, _ref, _ref1, _results;
      _results = [];
      for (i = _j = 0, _ref = this.get_heap_size(), _ref1 = AsmMod.page_size; 0 <= _ref ? _j < _ref : _j > _ref; i = _j += _ref1) {
        _results.push(i);
      }
      return _results;
    }).call(this);
  }

  AsmMod.prototype.get_heap_size = function() {
    return this.heap.byteLength;
  };

  AsmMod.prototype.push = function(module) {
    this.modules.push(module);
    return module(AsmMod.global, null, this.heap);
  };

  AsmMod.prototype.resize_heap = function(new_size) {
    var module, old_heap, old_size, _i, _len, _ref, _results;
    old_heap = this.heap;
    old_size = this.heap.byteLength;
    this.heap = new ArrayBuffer(new_size);
    console.log("new size", new_size);
    new Uint8Array(this.heap, 0, old_heap.byteLength).set(new Uint8Array(old_heap));
    _ref = this.modules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      module = _ref[_i];
      module(AsmMod.global, null, this.heap);
    }
    _results = [];
    while (old_size < new_size) {
      this.free_pages.push(old_size);
      _results.push(old_size += AsmMod.page_size);
    }
    return _results;
  };

  AsmMod.prototype.allocate = function(size) {
    var f, next_power_of_two, num_free_list, o, p, res;
    if (size >= AsmMod.page_size) {
      return this._allocate_pages((size / AsmMod.page_size) | 0);
    }
    next_power_of_two = function(v) {
      --v;
      v |= v >> 1;
      v |= v >> 2;
      v |= v >> 4;
      v |= v >> 8;
      v |= v >> 16;
      return ++v;
    };
    size = size <= 4 ? 4 : next_power_of_two(size);
    p = this.busy_pages.get(size);
    if (!p.free.length) {
      o = this._allocate_chuncks(size);
      p.free.push({
        offset: o,
        ptr_last_free_elem: o
      });
    }
    num_free_list = 0;
    f = p.free[num_free_list];
    res = f.ptr_last_free_elem;
    f.ptr_last_free_elem = (new Uint32Array(this.heap, res, 4))[0];
    if (f.ptr_last_free_elem === 1) {
      p.full.push(f.offset);
      p.free.splice(num_free_list, 1);
    }
    return {
      ptr: res,
      rese: size
    };
  };

  AsmMod.prototype._allocate_pages = function(nb_pages) {
    var contiguous, i, res, _i, _ref;
    while (true) {
      contiguous = function(i) {
        var o, _i;
        for (o = _i = 1; 1 <= nb_pages ? _i < nb_pages : _i > nb_pages; o = 1 <= nb_pages ? ++_i : --_i) {
          if (this.free_pages[i + o] !== this.free_pages[i + o - 1] + AsmMod.page_size) {
            return false;
          }
        }
        return true;
      };
      for (i = _i = 0, _ref = this.free_pages.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (contiguous(i)) {
          res = this.free_pages[i];
          this.free_pages.splice(i, nb_pages);
          return res;
        }
      }
      this.resize_heap(this.get_heap_size() * 2);
    }
  };

  AsmMod.prototype._allocate_chuncks = function(size) {
    var a32, i, res, _i, _ref;
    res = this._allocate_pages(1);
    a32 = new Uint32Array(this.heap, res, AsmMod.page_size);
    for (i = _i = 0, _ref = AsmMod.page_size - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = _i += size) {
      a32[i / 4] = res + i + size;
    }
    a32[(AsmMod.page_size - size) / 4] = 1;
    return res;
  };

  return AsmMod;

})();

asm_mod = new AsmMod;
